'use strict';

const fs = require('fs');
const ubus = (function() {
    try {
        return require('ubus').connect();
    } catch (e) {
        return { call: function() { return {}; } };
    }
})();

function get_status() {
    let kernel_ver = "未知";
    try {
        let board_info = ubus.call('system', 'board');
        if (board_info && board_info.kernel) {
            kernel_ver = board_info.kernel;
        }
    } catch (e1) {
        try {
            let proc_ver = fs.readfile('/proc/version') || "";
            let ver_match = proc_ver.match(/Linux version (\d+\.\d+\.\d+)/);
            if (ver_match && ver_match[1]) {
                kernel_ver = ver_match[1];
            }
        } catch (e2) {}
    }

    let sw_flow = false;
    try {
        let fw_status = ubus.call('firewall', 'status');
        if (fw_status && fw_status.offloading && fw_status.offloading.enabled === true) {
            sw_flow = true;
        }
    } catch (e1) {
        try {
            let cfg = fs.readfile('/etc/config/firewall') || "";
            sw_flow = cfg.includes('flow_offloading=\'1\'') || cfg.includes('flow_offloading=1');
        } catch (e2) {
            try {
                fs.access('/sys/module/nft_flow_offload');
                sw_flow = true;
            } catch (e3) {}
        }
    }

    let bbr = false;
    try {
        let cc = (fs.readfile('/proc/sys/net/ipv4/tcp_congestion_control') || "").trim();
        bbr = (cc === "bbr") || (cc === "tcp_bbr");
    } catch (e) {}

    let fullcone = false;
    try {
        fs.access('/sys/module/nft_fullcone');
        fullcone = true;
    } catch (e) {}

    return {
        sw_flow: sw_flow,
        bbr: bbr,
        fullcone: fullcone,
        kernel: kernel_ver
    };
}

return {
    'luci.turboacc': {
        get_status: {
            call: get_status
        }
    }
};
